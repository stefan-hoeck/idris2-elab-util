# Deriving Functionality for Data Types

In this section, we are going to have a look at the functionality
provided by the `Derive.*` submodules of the elab-util library,
and I'll explain some of the design decisions and limitations of the
chosen approach.

This library provides many utilities for deriving new types and functions
from the structure of existing data types. It is, for instance, desirable to
derive implementations of standard interfaces like `Eq` and `Ord` automatically
for as many data types as possible. Similar functionality is provided by other
programming languages such as Haskell.

In Idris, this poses several challenges:

* We need to generate the necessary clauses for every constructor of
  the data type we are currently inspecting.
* We need to come up with the necessary *constraints* required to
  implement an interface.
* We need to inform users of our library about why things didn't work
  out as expected in case they try to derive some functionality for a
  kind of data type currently not supported by our library.

The first point is often the most straight forward: Get hold of a
`Language.Reflection.Types.TypeInfo`, inspect its structure and come
up with the necessary top-level declarations, possibly after refining it further
by using some predicates. In this tutorial, I have shown in
detail, how such top-level declarations can be generated by means of
elaborator reflection.

The second point requires some compromises: It can be very hard to
come up with the correct set of constraints when implementing an
interface for an indexed type. We therefore typically only accept
a subset corresponding roughly to Haskell 98 parameterized data types
when automatically deriving constraints for interfaces of type
`Type -> Type` such as `Eq` or `Semigroup`.

Some more compromises are required for the third point: If we need to
refine the set of acceptable data types, we need to tell users if and
why this refinement failed. On the other hand, it is not always possible
(nor is it strictly necessary) to refine acceptable data types in such
a way that the derived functionality will always type check. In that case,
we let the type checker do its work and inform users about the
errors that occurred (if any).

```idris
module Doc.Derive

import Derive.Prelude

%language ElabReflection
%default total
```

## Some Examples

Let's derive `Eq` for a couple of data types. The implementations we
generate should pattern match on two values of the desired type,
comparing all arguments of matching constructors, and terminating
with a catch-all pattern returning `False` to handle the case
of non-matching constructors.

```idris
||| A simple error type for a hypothetical parser
||| of CSV files.
data Error : Type where
  EndOfInput   : Error
  NotABool     : String -> Error
  NotAnInteger : String -> Error

%runElab derive "Error" [Eq]
```
