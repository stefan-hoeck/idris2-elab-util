# Deriving Functionality for Data Types

In this section, we are going to have a look at the functionality
provided by the `Derive.*` submodules of the elab-util library,
and I'll explain some of the design decisions and limitations of the
chosen approach.

This library provides many utilities for deriving new types and functions
from the structure of existing data types. It is, for instance, desirable to
derive implementations of standard interfaces like `Eq` and `Ord` automatically
for as many data types as possible. Similar functionality is provided by other
programming languages such as Haskell.

In Idris, this poses several challenges:

* We need to generate the necessary clauses for every constructor of
  the data type we are currently inspecting.
* We need to come up with the necessary *constraints* required to
  implement an interface.
* We need to inform users of our library about why things didn't work
  out as expected in case they try to derive some functionality for a
  kind of data type currently not supported by our library.

The first point is often the most straight forward: Get hold of a
`Language.Reflection.Types.TypeInfo`, inspect its structure and come
up with the necessary top-level declarations, possibly after refining it further
by using some predicates. In this tutorial, I have shown in
detail, how such top-level declarations can be generated by means of
elaborator reflection.

The second point requires some compromises: It can be very hard to
come up with the correct set of constraints when implementing an
interface for an indexed type. We therefore typically only accept
a subset corresponding roughly to Haskell 98 parameterized data types
when automatically deriving constraints for interfaces of type
`Type -> Type` such as `Eq` or `Semigroup`.

Some more compromises are required for the third point: If we need to
refine the set of acceptable data types, we need to tell users if and
why this refinement failed. On the other hand, it is not always possible
(nor is it strictly necessary) to refine acceptable data types in such
a way that the derived functionality will always type check. In that case,
we let the type checker do its work and inform users about the
errors that occurred (if any).

```idris
module Doc.Derive

import Language.Reflection.Pretty
import Derive.Prelude

%language ElabReflection
%default total
```

## Constant Type Constructors

Let's derive `Eq` for a couple of data types. The implementations we
generate should pattern match on two values of the desired type,
comparing all arguments of matching constructors, and terminating
with a catch-all pattern returning `False` to handle the case
of non-matching constructors.

```idris
||| A simple error type for a hypothetical parser
||| of CSV files.
data Error : Type where
  EndOfInput   : Error
  NotABool     : String -> Error
  NotAnInteger : String -> Error

%runElab derive "Error" [Eq]
```
The above will generate two functions as shown below with a ticked
version of the data type:

```idris
data Error' : Type where
  EndOfInput'   : Error'
  NotABool'     : String -> Error'
  NotAnInteger' : String -> Error'

public export
eqError' : Error' -> Error' -> Bool

public export %inline %hint
eqImplError' : Eq Error'

eqError' EndOfInput' EndOfInput' = True
eqError' (NotABool' x0) (NotABool' y0) = x0 == y0
eqError' (NotAnInteger' x0) (NotAnInteger' y0) = x0 == y0
eqError' _ _ = False

eqImplError' = mkEq eqError'
```

As can be seen, all function declarations are generated first, followed by
the implementations. This will be important, once we derive interfaces
for recursive types.

Implementations such as the one for `Error` are mechanical and don't
require much though. Here is a slightly more interesting example:

```idris
record Positive where
  constructor MkPositive
  val : Nat
  0 prf : IsSucc val

%runElab derive "Positive" [Show,Eq,Ord]
```

We interpret boolean equality as mainly a runtime check, so the produced
code just ignores the erased field. In the above case, this works fine,
but in the general case, it doesn't. Lets have a look at a sigma
type:

```idris
record Strings where
  constructor MkStrings
  length  : Nat
  strings : Vect length String
```

It is still possible to derive `Show` for such a type:

```idris
%runElab derive "Strings" [Show]
```

But deriving `Eq` will fail:

```idris
failing "Mismatch between: x0 and y0"
  %runElab derive "Strings" [Eq]
```

The problem here is, that we only have an `Eq` instance for `Vect n`, which
can compare vectors of the same length. But when comparing two values
of type `Strings`, the `length`s might be distinct, and therefore,
comparing the two vectors fails with a unification error. In order to fix this,
we'd first have to run a test for propositional equality on the `length`, but
I haven't figured out a clean and general way to do that automatically.

### Restrictions on Data Types

Some interfaces can only be derived easily for single-constructor data types.
Examples include `Num`, `Semigroup`, or `Monoid`. Here's an example:

```idris
record Log where
  constructor MkLog
  errors   : List Error
  messages : List String

%runElab derive "Log" [Semigroup,Monoid]
```

For data types with several constructors, this will fail:

```idris
data Log2 : Type where
  Empty    : Log2
  Messages : List String -> Log2

failing "Semigroup can only be derived for single-constructor data types"
  %runElab derive "Log2" [Semigroup,Monoid]
```

Even though there are some restrictions considering the number of
data constructors we support when deriving `Semigroup`, the procedure
for record types is straight-forward. So straight-forward, that it can
actually be (ab)used even in the presence of certain predicates:

```idris
(<+>) :
     {xs,ys : List a}
  -> NonEmpty xs
  -> NonEmpty ys
  -> NonEmpty (xs <+> ys)
IsNonEmpty <+> _ = IsNonEmpty

record NE where
  constructor MkNE
  errors : List Error
  0 prf  : NonEmpty errors

%runElab derive "NE" [Semigroup]
```

As can be guessed from the example above, the generated code
uses `(<+>)` on both explicit record fields, the value and the
erased proof.

Unfortunately, we can't get this to work with auto-implicit proofs:

```idris
%hint
0 autoApp :
     {xs,ys : List a}
  -> NonEmpty xs
  => NonEmpty ys
  => NonEmpty (xs <+> ys)
autoApp @{IsNonEmpty} = IsNonEmpty

record NE2 where
  constructor MkNE2
  errors2 : List Error
  {auto 0 prf  : NonEmpty errors2}

failing "Can't find an implementation for NonEmpty"
  %runElab derive "NE2" [Semigroup]
```

Even though we provided a `%hint`, Idris2 won't come up with the
desired proof on its own, probably due to ambiguities during proof
search.

We could of course implement deriving of `Semigroup` in such a way, that
it also runs `(<+>)` explicitly on auto-implicit arguments, but I
decided against this, because it's clearly against the spirit of
the general auto-implicit argument: The compiler is expected to
come up with a proof on its own most of the time.

### Optimizations

Some data types make it possible to at runtime get rid of almost any
Idris2 traces. For instance, types consisting only of constant constructors
at runtime (enumerations with and without erased implicit or explicit arguments)
can be converted to their runtime representation (a fixed-width unsigned integer,
typically `Bits8` if the enum has fewer than 256 constructors) at zero cost:
The conversion function gets detected as the identity function by the Idris
compiler, and is optimized away completely during code generation.

For runtime enumerations, the deriving mechanism of this library will
automatically generate this conversion function and use it in the
implementations of `Eq` and `Ord`:

```idris
data Weekday : Type where
  Monday    : Weekday
  Tuesday   : Weekday
  Wednesday : Weekday
  Thursday  : Weekday
  Friday    : Weekday
  Saturday  : Weekday
  Sunday    : Weekday

%runElab derive "Weekday" [Show, Eq, Ord]

testConIndex : conIndexWeekday Wednesday === 2
testConIndex = Refl

main : IO ()
main = printLn $ Monday == Tuesday
```

Here is the JavaScript code generated for the `main` function above:

```javascript
function Doc_Derive_main($0) {
 return Prelude_IO_prim__putStr(
   (Prelude_Show_show_Show_Bool(
     Prelude_EqOrd_x3dx3d_Eq_Bits8(0, 1))+'\n'
   ), $0
 );
}
```

As can be seen, function `conIndexWeekday` as well as interface implementation
`eqImplWeekday` have been completely optimized away.

## Parameterized Types

The examples shown so far were not too hard to derive:
We needed to implement a pattern clause for every constructor, dealing
with every constructor argument individually, combining the intermediary
results in a single value. In case of `Eq` implementations for data types
with more than one constructor, we had to append a catch-all clause
returning `False` when comparing non-matching constructors.

Things get a lot trickier once we start to derive implementations for
parameterized or indexed data types, and we are going to have a look
at several examples next.

```idris
data Result : Type -> Type -> Type where
  Failure : (err : e) -> Result e a
  Success : (val : a) -> Result e a
  Aborted : Result e a

%runElab derive "Result" [Show, Eq]
```

If we implemented `Eq` for `Result` ourselves, the implementation would
require two additional constraints on the parameters:

```idris
manualEqResult : Eq a => Eq b => Eq (Result a b)
```

Indeed, this is what is generated by the code above. But that's just the tip
of the iceberg. Let's introduce a phantom type, and see what happens next:

```idris
data Const : (c,a : Type) -> Type where
  MkConst : (val : c) -> Const c a


%runElab derive "Const"
  [FromDouble, Show, Eq, Ord, Semigroup, Monoid, Num, Abs, Neg, Integral, Fractional]
```

That's *a lot* of interfaces, but do they behave correctly? Certainly, the necessary
constraints are only required for the first parameter, the second is a
phantom type. Let's see, how this goes:

```idris
twelve : Const Integer Void
twelve = 20 - 8
```

The deriving mechanism keeps track of where in the constructor arguments
a parameter makes an appearance, and whether a corresponding constraint
is required as a prerequisite. This works even for more complex parameters:

```idris
record Barbie (f : Type -> Type) (a : Type) where
  constructor MkBarbie
  id   : f a
  name : f String
  age  : f Nat

%runElab derive "Barbie" [Show, Eq]

barbie : Barbie (Prelude.id) Integer
barbie = MkBarbie 1 "Stefan" 30

emptyBarbie : Barbie List Void
emptyBarbie = MkBarbie [] [] []

testBarbie : (Derive.barbie == Derive.barbie) === True
testBarbie = Refl
```
And at the REPL:

```repl
Doc.Derive> show emptyBarbie
"MkBarbie {id = [], name = [], age = []}"
```

As can be seen, even for complex parameters, the deriving mechanism
typically comes up with the correct constraints.

### Indexed Types

But we can do more: Sometimes we want to instruct Idris to ignore
a certain parameter, even though values of its type make an appearance
at runtime. Or we actually do not have a *parameter* but an *index*,
which changes depending on the constructor we use. For such
cases, we can use `deriveIndexed`, telling the deriving utilities to
ignore all type arguments when creating an implementation's constraints.

In a first example, we'd like to implement `Semigroup` for a parameterized
data type, where the fields consist of container types, which are
semigroups even if the values they hold are not:

```idris
record Results a b where
  constructor MkResults
  successes : List a
  failure   : Maybe b

%runElab derive "Results" [Show, Eq]

%runElab deriveIndexed "Results" [Semigroup, Monoid]

emptyResults : Results Void Void
emptyResults = neutral
```

As can be seen above, we need to different deriving mechanisms: One for `Show` and
`Eq`, which should create the necessary constraints in order for us
to be able to compare two `Results` values, and a second for `Semigroup` and
`Monoid`, for which additional constraints would be unnecessarily restrictive.

It is, of course, always possible to list the generated functions and inspect
their types at the REPL:

```repl
Doc.Derive> :t eqResults
Doc.Derive.eqResults : Eq a => Eq b => Results a b -> Results a b -> Bool
Doc.Derive> :t appendResults
Doc.Derive.appendResults : Results a b -> Results a b -> Results a b
```

Let's derive some implementations for a truly indexed type:

```idris
data Expr : (t : Type) -> Type where
  Lit        : Nat -> Expr Nat
  IsSucc     : Expr Nat -> Expr Bool
  Plus       : Expr Nat -> Expr Nat -> Expr Nat
  IfThenElse : Expr Bool -> Expr a -> Expr a -> Expr a

%runElab deriveIndexed "Expr" [Show, Eq]
```

```repl
Doc.Derive> show $ IfThenElse (IsSucc $ Lit 0) (Lit 12) (Plus (Lit 8) (Lit 10))
"IfThenElse (IsSucc (Lit 0)) (Lit 12) (Plus (Lit 8) (Lit 10))"
```

It works! And, as we can easily verify, no additional constraint has been
added for the index:

```repl
Doc.Derive> :t showPrecExpr
Doc.Derive.showPrecExpr : Prec -> Expr t -> String
```

### Mixing Parameters and Indices

Can we take this even further? What about a binary tree type, that
keeps track of the number of leaves in an index, parameterized
by the type of values it holds?

```idris
data Tree : (n : Nat) -> (a : Type) -> Type where
  TEmpty : Tree 0 a
  Leaf   : (val : a) -> Tree 1 a
  Branch : (left : Tree m a) -> (right : Tree n a) -> Tree (m + n) a
```

Clearly, we will not be possible to derive `Eq` for this - for the same
reasons it didn't work out for the `Strings` example at the beginning
of this chapter: The size indices will not match. `Show` should be possible,
however, if we can tell the deriving mechanism exactly, which type
arguments are indices and which are parameters. Function `derivePattern`
lets us do exactly that:

```idris
%runElab derivePattern "Tree" [I,P] [Show]
```

The pattern passed to `derivePattern` makes it clear that the first
type argument should be considered an index (or it should just be
*i*gnored when coming up with the necessary constraints) and the
second should be treated as a parameter.
